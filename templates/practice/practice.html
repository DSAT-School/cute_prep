{% extends "base_dashboard.html" %}
{% load static %}

{% block title %}Practice - DSAT SCHOOL{% endblock %}

{% block extra_css %}
<style>
    /* Practice Interface Styles */

    .practice-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1rem;
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        margin-bottom: 1rem;
    }

    .timer {
        font-size: 1.25rem;
        font-weight: 600;
        color: #262632;
    }

    .skill-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.375rem 0.75rem;
        background: #f3e8ff;
        border-radius: 6px;
        font-size: 0.75rem;
        font-weight: 600;
        color: #7c3aed;
    }

    .domain-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.375rem 0.75rem;
        background: #dbeafe;
        border-radius: 6px;
        font-size: 0.75rem;
        font-weight: 600;
        color: #1e40af;
    }

    .hide-timer-btn {
        padding: 0.375rem 0.75rem;
        font-size: 0.875rem;
        background: white;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .hide-timer-btn:hover {
        background: #f3f4f6;
    }

    .annotate-btn {
        padding: 0.375rem 0.75rem;
        font-size: 0.875rem;
        background: white;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .annotate-btn:hover {
        background: #f3f4f6;
    }

    .show-details-btn {
        padding: 0.375rem 0.75rem;
        font-size: 0.875rem;
        background: #9967b9;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        font-weight: 600;
    }

    .show-details-btn:hover {
        background: #7c4d9a;
    }

    .attempt-info-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.375rem;
        padding: 0.375rem 0.75rem;
        background: #fef3c7;
        border: 1px solid #fbbf24;
        border-radius: 6px;
        font-size: 0.75rem;
        font-weight: 600;
        color: #92400e;
    }

    .attempt-info-badge i {
        font-size: 0.875rem;
    }

    .last-attempt-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 600;
        margin-left: 0.5rem;
    }

    .last-attempt-badge.correct {
        background: #d1fae5;
        color: #065f46;
        border: 1px solid #10b981;
    }

    .last-attempt-badge.incorrect {
        background: #fee2e2;
        color: #991b1b;
        border: 1px solid #ef4444;
    }

    .history-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        padding: 0.625rem 1rem;
        background: white;
        border: 1px solid #92400e;
        border-radius: 6px;
        cursor: pointer;
        color: #92400e;
        transition: all 0.2s;
        position: relative;
        font-size: 0.9375rem;
        font-weight: 600;
    }

    .history-btn:hover {
        background: #92400e;
        color: white;
    }

    .history-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 1.25rem;
        height: 1.25rem;
        padding: 0 0.25rem;
        background: #fdcc4c;
        color: #78350f;
        border-radius: 10px;
        font-size: 0.75rem;
        font-weight: 700;
    }

    /* Attempt History Modal */
    .attempt-history-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 60;
        align-items: center;
        justify-content: center;
    }

    .attempt-history-modal.show {
        display: flex;
    }

    .attempt-history-content {
        background: white;
        border-radius: 8px;
        padding: 1rem;
        max-width: 450px;
        width: 90%;
        max-height: 70vh;
        overflow-y: auto;
        position: relative;
    }

    .attempt-history-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.75rem;
        padding-bottom: 0.75rem;
        border-bottom: 1px solid #e5e7eb;
    }

    .attempt-history-header h3 {
        font-size: 1rem;
        font-weight: 700;
        color: #262632;
    }

    .attempt-history-list {
        display: flex;
        flex-direction: column;
        gap: 0.625rem;
    }

    .attempt-item {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem;
        background: #f9fafb;
        border-radius: 6px;
        border: 1px solid #e5e7eb;
    }

    .attempt-number {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 2rem;
        height: 2rem;
        background: #262632;
        color: white;
        font-weight: 700;
        font-size: 0.8125rem;
        border-radius: 50%;
        flex-shrink: 0;
    }

    .attempt-details {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 0.125rem;
    }

    .attempt-answer {
        font-size: 0.8125rem;
        font-weight: 600;
    }

    .attempt-answer.correct {
        color: #065f46;
    }

    .attempt-answer.incorrect {
        color: #991b1b;
    }

    .attempt-time {
        font-size: 0.6875rem;
        color: #6b7280;
    }

    .attempt-status-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.6875rem;
        font-weight: 600;
        flex-shrink: 0;
    }

    .attempt-status-badge.correct {
        background: #d1fae5;
        color: #065f46;
        border: 1px solid #10b981;
    }

    .attempt-status-badge.incorrect {
        background: #fee2e2;
        color: #991b1b;
        border: 1px solid #ef4444;
    }

    /* Question Details Modal */
    .question-details-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0; /* Cover entire viewport */
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 50;
        align-items: center;
        justify-content: center;
    }

    .question-details-modal.show {
        display: flex;
    }

    .question-details-content {
        background: white;
        border-radius: 12px;
        padding: 1.5rem;
        max-width: 500px;
        width: 90%;
        position: relative;
    }

    .question-details-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        padding-bottom: 1rem;
        border-bottom: 2px solid #e5e7eb;
    }

    .question-details-header h3 {
        font-size: 1.125rem;
        font-weight: 700;
        color: #262632;
    }

    .question-details-body {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    .detail-item {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
    }

    .detail-label {
        font-size: 0.75rem;
        font-weight: 600;
        color: #6b7280;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .detail-value {
        font-size: 0.875rem;
        color: #262632;
    }

    .practice-content {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        margin-bottom: 1rem;
    }

    .practice-content.no-stimulus {
        grid-template-columns: 1fr;
        max-width: 900px;
        margin: 0 auto 1rem auto;
    }

    .practice-content.no-stimulus .stimulus-panel {
        display: none;
    }

    .practice-content.no-stimulus .question-panel {
        height: calc(100vh - 220px);
    }

    .stimulus-panel,
    .question-panel {
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 2rem;
        height: calc(100vh - 220px);
        overflow-y: auto;
        font-size: 1.125rem;
        font-family: 'Noto Serif', serif;
    }

    .stimulus-panel #stimulus-content,
    .question-panel #question-content {
        display: block;
        width: 100%;
    }

    .stimulus-panel p,
    .question-panel p {
        font-size: 1.125rem;
    }

    .stimulus-panel strong,
    .question-panel strong {
        font-weight: 600;
        color: #1f2937;
    }

    .question-number {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 2rem;
        height: 2rem;
        background: #262632;
        color: white;
        font-weight: 600;
        font-size: 0.875rem;
        border-radius: 4px;
        margin-bottom: 1rem;
    }

    .mark-toggle-btn {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        font-size: 0.875rem;
        font-weight: 600;
        border: 2px solid #d1d5db;
        border-radius: 6px;
        background: white;
        color: #6b7280;
        cursor: pointer;
        transition: all 0.2s;
        margin-bottom: 1rem;
        font-family: 'Montserrat', sans-serif;
    }

    .mark-toggle-btn:hover {
        background: #f9fafb;
        border-color: #9ca3af;
    }

    .mark-toggle-btn.marked {
        background: #9967b9;
        color: white;
        border-color: #9967b9;
    }

    .mark-toggle-btn.marked:hover {
        background: #7c4d9a;
        border-color: #7c4d9a;
    }

    .mastered-toggle-btn {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        font-size: 0.875rem;
        font-weight: 600;
        border: 2px solid #d1d5db;
        border-radius: 6px;
        background: white;
        color: #6b7280;
        cursor: pointer;
        transition: all 0.2s;
        margin-bottom: 1rem;
        font-family: 'Montserrat', sans-serif;
    }

    .mastered-toggle-btn:hover {
        background: #f9fafb;
        border-color: #9ca3af;
    }

    .mastered-toggle-btn.mastered {
        background: #10b981;
        color: white;
        border-color: #10b981;
    }

    .mastered-toggle-btn.mastered:hover {
        background: #059669;
        border-color: #059669;
    }

    .question-text {
        font-size: 1.125rem;
        color: #1f2937;
        font-family: 'Noto Serif', serif;
    }

    .answer-options {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .answer-option {
        display: flex;
        align-items: center;
        padding: 0.625rem 0.875rem;
        background: #f9fafb;
        border: 2px solid #e5e7eb;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s;
        font-family: 'Noto Serif', serif;
        min-height: fit-content;
    }

    .answer-option:hover {
        background: #f3f4f6;
        border-color: #9967b9;
    }

    .answer-option.selected {
        background: #f3e8ff;
        border-color: #9967b9;
    }

    .answer-option.correct {
        background: #d1fae5;
        border-color: #10b981;
    }

    .answer-option.incorrect {
        background: #fee2e2;
        border-color: #ef4444;
    }

    .option-label {
        font-weight: 600;
        font-size: 1.125rem;
        color: #262632;
        margin-right: 0.75rem;
        min-width: 1.75rem;
        flex-shrink: 0;
    }

    .option-text {
        font-size: 1.125rem;
        color: #374151;
        flex: 1;
        font-family: 'Noto Serif', serif;
        line-height: 1.6;
    }

    .strikethrough-btn {
        width: 1.5rem;
        height: 1.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
        background: white;
        border: 1px solid #d1d5db;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.75rem;
        color: #6b7280;
        flex-shrink: 0;
        margin-left: 0.5rem;
    }

    .strikethrough-btn:hover {
        background: #f3f4f6;
    }

    .strikethrough-btn.active {
        background: #fee2e2;
        border-color: #ef4444;
        color: #dc2626;
    }

    .practice-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem;
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 40;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
    }

    .practice-container {
        max-width: 1920px;
        margin: 0 auto;
        padding: 1.5rem 3rem;
        padding-bottom: 6rem; /* Add space for fixed footer */
    }

    .question-counter {
        padding: 0.625rem 1.25rem;
        background: #262632;
        color: white;
        border-radius: 6px;
        font-size: 0.9375rem;
        font-weight: 600;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
    }

    .navigation-buttons {
        display: flex;
        gap: 0.75rem;
    }

    .nav-btn {
        padding: 0.625rem 1.5rem;
        font-size: 0.875rem;
        font-weight: 600;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        border: none;
    }

    .nav-btn.back {
        background: #e5e7eb;
        color: #374151;
    }

    .nav-btn.back:hover {
        background: #d1d5db;
    }

    .nav-btn.next {
        background: #3b82f6;
        color: white;
    }

    .nav-btn.next:hover {
        background: #2563eb;
    }

    .nav-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .explanation-panel {
        background: #fef3c7;
        border: 1px solid #fbbf24;
        border-radius: 8px;
        padding: 1rem;
        margin-top: 1rem;
        display: none;
    }

    .explanation-panel.show {
        display: block;
    }

    .explanation-title {
        font-size: 0.875rem;
        font-weight: 600;
        color: #92400e;
        margin-bottom: 0.5rem;
    }

    .explanation-text {
        font-size: 1.125rem;
        line-height: 1.8;
        color: #78350f;
        font-family: 'Noto Serif', serif;
    }

    /* Scrollbar styling */
    .stimulus-panel::-webkit-scrollbar,
    .question-panel::-webkit-scrollbar {
        width: 8px;
    }

    .stimulus-panel::-webkit-scrollbar-track,
    .question-panel::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 4px;
    }

    .stimulus-panel::-webkit-scrollbar-thumb,
    .question-panel::-webkit-scrollbar-thumb {
        background: #9967b9;
        border-radius: 4px;
    }

    .stimulus-panel::-webkit-scrollbar-thumb:hover,
    .question-panel::-webkit-scrollbar-thumb:hover {
        background: #7c4d9a;
    }

    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
        .practice-container {
            padding: 0.75rem;
            padding-bottom: 8rem;
        }

        .practice-footer {
            padding: 0.75rem;
            border-radius: 0;
            border-left: none;
            border-right: none;
            border-bottom: none;
        }

        .practice-header {
            padding: 0.75rem;
        }

        .practice-header > div {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .timer {
            font-size: 1rem;
        }

        .hide-timer-btn,
        .show-details-btn,
        .annotate-btn {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
        }

        .attempt-info-badge {
            display: none !important;
        }

        .history-btn {
            display: inline-flex !important;
        }

        .last-attempt-badge {
            font-size: 0.65rem;
            padding: 0.2rem 0.4rem;
            margin-left: 0.25rem;
        }

        .history-btn {
            width: 1.5rem;
            height: 1.5rem;
            font-size: 0.75rem;
        }

        .attempt-history-content {
            width: 95%;
            padding: 1.25rem;
        }

        .attempt-item {
            flex-direction: column;
            align-items: flex-start;
        }

        .attempt-number {
            width: 2rem;
            height: 2rem;
            font-size: 0.75rem;
        }

        .attempt-status-badge {
            align-self: flex-end;
        }

        .question-details-content {
            width: 95%;
            padding: 1.25rem;
        }

        .skill-badge,
        .domain-badge {
            font-size: 0.688rem;
            padding: 0.25rem 0.5rem;
        }

        .practice-content {
            grid-template-columns: 1fr;
            gap: 0;
            display: flex;
            flex-direction: column;
        }

        .practice-content.no-stimulus {
            display: block;
        }

        .stimulus-panel,
        .question-panel {
            padding: 1rem;
            height: auto !important;
            min-height: auto !important;
            max-height: none !important;
            overflow-y: visible !important;
            font-size: 1rem;
            border: none;
            font-family: 'Noto Serif', serif;
        }

        .stimulus-panel {
            order: -1; /* Show stimulus before question on mobile */
            border-bottom: 2px solid #e5e7eb;
            border-radius: 0;
            margin-bottom: 0;
        }

        .question-panel {
            border-radius: 0;
        }

        .stimulus-panel #stimulus-content,
        .question-panel #question-content {
            height: auto !important;
            max-height: none !important;
            overflow: visible !important;
        }

        .question-number {
            width: 1.75rem;
            height: 1.75rem;
            font-size: 0.75rem;
        }

        .mark-toggle-btn {
            font-size: 0.75rem;
            padding: 0.375rem 0.75rem;
        }

        .mastered-toggle-btn {
            font-size: 0.75rem;
            padding: 0.375rem 0.75rem;
        }

        /* Hide certain elements on mobile */
        .hide-on-mobile {
            display: none !important;
        }

        /* Action buttons side by side */
        .action-buttons-group {
            display: flex;
            gap: 0.5rem;
            flex: 1;
        }

        .action-buttons-group .nav-btn {
            flex: 1;
            min-width: auto;
        }

        .question-text {
            font-size: 1rem;
            margin-bottom: 1rem;
            font-family: 'Noto Serif', serif;
        }

        .answer-option {
            padding: 0.625rem 0.75rem;
            font-size: 1rem;
            font-family: 'Noto Serif', serif;
        }

        .option-label {
            font-size: 1rem;
            margin-right: 0.5rem;
        }

        .option-text {
            font-size: 1rem;
            font-family: 'Noto Serif', serif;
        }

        .strikethrough-btn {
            width: 1.25rem;
            height: 1.25rem;
            font-size: 0.625rem;
        }

        .practice-footer {
            flex-direction: column;
            gap: 0.5rem;
            padding: 0.75rem 0.5rem;
        }

        .question-counter {
            padding: 0.5rem 0.875rem;
            font-size: 0.8125rem;
            width: auto;
            text-align: center;
            flex: 1;
            gap: 0.375rem;
        }

        .history-btn {
            padding: 0.5rem 0.875rem;
            font-size: 0.8125rem;
            width: auto;
            min-width: fit-content;
            gap: 0.375rem;
        }

        .navigation-buttons {
            width: 100%;
            gap: 0.375rem;
            flex-wrap: wrap;
        }

        .nav-btn {
            flex: 1 1 auto;
            min-width: calc(50% - 0.1875rem);
            padding: 0.625rem 0.5rem;
            font-size: 0.75rem;
            white-space: nowrap;
        }

        .explanation-panel {
            padding: 0.75rem;
            margin-top: 0.75rem;
        }

        .explanation-title {
            font-size: 0.875rem;
        }

        .explanation-text {
            font-size: 1rem;
            font-family: 'Noto Serif', serif;
        }

        .question-map-content {
            width: 95%;
            padding: 1rem;
            max-height: 90vh;
        }

        .question-map-header h3 {
            font-size: 1rem;
        }

        .question-map-legend {
            gap: 0.5rem;
            padding: 0.5rem;
        }

        .legend-item {
            font-size: 0.688rem;
        }

        .legend-box {
            width: 1.25rem;
            height: 1.25rem;
        }

        .question-map-grid {
            grid-template-columns: repeat(auto-fill, minmax(2.5rem, 1fr));
            gap: 0.5rem;
        }

        .question-map-item {
            font-size: 0.75rem;
        }
    }

    /* Extra small devices (phones in portrait, less than 576px) */
    @media (max-width: 576px) {
        .practice-container {
            padding: 0.5rem;
            padding-bottom: 9rem;
        }

        .practice-header {
            padding: 0.5rem;
            gap: 0.5rem;
        }

        /* Hide certain elements on small mobile */
        .hide-on-small-mobile {
            display: none !important;
        }

        .timer {
            font-size: 0.875rem;
        }

        .skill-badge,
        .domain-badge {
            font-size: 0.625rem;
            padding: 0.25rem 0.375rem;
        }

        .stimulus-panel,
        .question-panel {
            padding: 0.75rem;
            border-radius: 6px;
            max-height: 50vh;
            font-family: 'Noto Serif', serif;
        }

        .answer-option {
            padding: 0.625rem;
            gap: 0.5rem;
        }

        .practice-footer {
            padding: 0.5rem 0.375rem;
        }

        .nav-btn {
            padding: 0.5rem 0.375rem;
            font-size: 0.688rem;
        }
        
        .nav-btn i {
            font-size: 0.875rem;
        }
    }

    /* Landscape orientation for mobile devices */
    @media (max-width: 896px) and (orientation: landscape) {
        .practice-content {
            grid-template-columns: 1fr 1fr;
        }

        .stimulus-panel,
        .question-panel {
            height: calc(100vh - 240px);
            max-height: calc(100vh - 240px);
        }

        .stimulus-panel {
            order: 0; /* Reset order in landscape */
        }
    }

    /* Loading state */
    .loading {
        text-align: center;
        padding: 3rem;
        color: #6b7280;
    }

    /* Empty state */
    .empty-state {
        text-align: center;
        padding: 3rem;
        color: #6b7280;
    }

    .empty-state h3 {
        font-size: 1.25rem;
        font-weight: 600;
        color: #262632;
        margin-bottom: 0.5rem;
    }

    .empty-state p {
        font-size: 0.875rem;
        color: #6b7280;
    }

    /* Question Map Modal */
    .question-map-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0; /* Account for sidebar width */
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 50;
        align-items: center;
        justify-content: center;
    }

    .question-map-modal.show {
        display: flex;
    }

    .question-map-content {
        background: white;
        border-radius: 12px;
        padding: 1.5rem;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        position: relative;
    }

    .question-map-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        padding-bottom: 1rem;
        border-bottom: 2px solid #e5e7eb;
    }

    .question-map-header h3 {
        font-size: 1.125rem;
        font-weight: 700;
        color: #262632;
    }

    .close-modal-btn {
        background: none;
        border: none;
        font-size: 1.5rem;
        color: #6b7280;
        cursor: pointer;
        padding: 0;
        width: 2rem;
        height: 2rem;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
    }

    .close-modal-btn:hover {
        background: #f3f4f6;
        color: #262632;
    }

    .question-map-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        margin-bottom: 1.5rem;
        padding: 0.75rem;
        background: #f9fafb;
        border-radius: 8px;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.75rem;
        color: #6b7280;
    }

    .legend-box {
        width: 1.5rem;
        height: 1.5rem;
        border-radius: 4px;
        border: 2px solid #e5e7eb;
    }

    .legend-box.current {
        background: #7c3aed;
        border-color: #7c3aed;
        position: relative;
    }

    .legend-box.current::after {
        content: '✓';
        color: white;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.75rem;
        font-weight: bold;
    }

    .legend-box.answered {
        background: #10b981;
        border-color: #059669;
    }

    .legend-box.tried {
        background: #f59e0b;
        border-color: #d97706;
    }

    .legend-box.not-tried {
        background: #f8fafc;
        border-color: #cbd5e1;
    }

    .legend-box.marked {
        background: #8b5cf6;
        border-color: #7c3aed;
    }

    .question-map-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(3rem, 1fr));
        gap: 0.75rem;
    }

    .question-map-item {
        aspect-ratio: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid #cbd5e1;
        border-radius: 8px;
        background: #f8fafc;
        font-size: 0.875rem;
        font-weight: 700;
        color: #64748b;
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }

    .question-map-item:hover {
        transform: translateY(-2px) scale(1.05);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
        border-color: #94a3b8;
    }

    .question-map-item.current {
        background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
        border-color: #6d28d9;
        color: white;
        box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3);
    }

    .question-map-item.current::after {
        content: '✓';
        position: absolute;
        bottom: 3px;
        right: 3px;
        font-size: 0.625rem;
        font-weight: bold;
    }

    .question-map-item.answered,
    .question-map-item.mastered {
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        border-color: #059669;
        color: white;
        box-shadow: 0 2px 8px rgba(16, 185, 129, 0.25);
    }

    .question-map-item.mastered::before {
        content: '✓';
        position: absolute;
        top: 2px;
        right: 3px;
        font-size: 0.5rem;
        font-weight: bold;
        opacity: 0.8;
    }

    .question-map-item.tried {
        background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        border-color: #d97706;
        color: white;
        box-shadow: 0 2px 8px rgba(245, 158, 11, 0.25);
    }

    .question-map-item.marked {
        border-color: #8b5cf6;
        border-width: 3px;
        box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.2);
    }

    .question-map-item.mastered.marked {
        box-shadow: 0 2px 8px rgba(16, 185, 129, 0.25), 0 0 0 2px rgba(139, 92, 246, 0.3);
    }

    /* Alert Modal */
    .alert-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0; /* Cover entire viewport including sidebar */
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 60;
        align-items: center;
        justify-content: center;
    }

    .alert-modal.show {
        display: flex;
    }

    .alert-modal-content {
        background: white;
        border-radius: 12px;
        padding: 1.5rem;
        max-width: 400px;
        width: 90%;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
    }

    .alert-modal-message {
        font-size: 0.875rem;
        color: #374151;
        margin-bottom: 1.5rem;
        line-height: 1.5;
    }

    .alert-modal-buttons {
        display: flex;
        gap: 0.75rem;
        justify-content: flex-end;
    }

    .alert-modal-btn {
        padding: 0.5rem 1rem;
        border-radius: 6px;
        font-size: 0.875rem;
        font-weight: 600;
        cursor: pointer;
        border: none;
        transition: all 0.2s;
    }

    .alert-modal-btn.cancel {
        background: #f3f4f6;
        color: #374151;
    }

    .alert-modal-btn.cancel:hover {
        background: #e5e7eb;
    }

    .alert-modal-btn.confirm {
        background: #9967b9;
        color: white;
    }

    .alert-modal-btn.confirm:hover {
        background: #7c4d9a;
    }

    .alert-modal-btn.ok {
        background: #9967b9;
        color: white;
    }

    .alert-modal-btn.ok:hover {
        background: #7c4d9a;
    }

    /* Navigation Warning Tooltip */
    .nav-warning-tooltip {
        position: fixed;
        bottom: 6rem;
        left: 50%;
        transform: translateX(-50%);
        background: #fbbf24;
        color: #78350f;
        padding: 0.75rem 1.5rem;
        border-radius: 8px;
        font-size: 0.875rem;
        font-weight: 600;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 55;
        display: none;
        animation: slideUp 0.3s ease-out;
    }

    .nav-warning-tooltip.show {
        display: block;
    }

    @keyframes slideUp {
        from {
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="practice-container">
    <!-- Header with Timer and Controls -->
    <div class="practice-header">
        <div class="flex items-center gap-2">
            <button class="show-details-btn" onclick="toggleQuestionDetails()">
                <i class="fas fa-info-circle"></i> <span>About</span>
            </button>
        </div>
        <div class="flex items-center gap-2">
            <div class="timer" id="timer">0:00</div>
        </div>
        <div class="flex items-center gap-2">
            <button class="annotate-btn" onclick="toggleAnnotate()">
                <i class="fas fa-pen"></i> <span class="hide-on-mobile">Annotate</span>
            </button>
        </div>
    </div>

    <!-- Question Details Modal -->
    <div class="question-details-modal" id="question-details-modal">
        <div class="question-details-content">
            <div class="question-details-header">
                <h3>Question Details</h3>
                <button class="close-modal-btn" onclick="toggleQuestionDetails()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="question-details-body">
                <div class="detail-item">
                    <div class="detail-label">Domain</div>
                    <div class="detail-value">
                        <span class="domain-badge">
                            <span id="modal-domain-code">{{ first_question.domain_code }}</span>
                            <span id="modal-domain-name">{{ first_question.domain_name }}</span>
                        </span>
                    </div>
                </div>
                <div class="detail-item">
                    <div class="detail-label">Skill</div>
                    <div class="detail-value">
                        <span class="skill-badge">
                            <span id="modal-skill-code">{{ first_question.skill_code }}</span>
                            <span id="modal-skill-name">{{ first_question.skill_name }}</span>
                        </span>
                    </div>
                </div>
                <div class="detail-item">
                    <div class="detail-label">Question Number</div>
                    <div class="detail-value" id="modal-question-number">1 of {{ total_questions }}</div>
                </div>
            </div>
        </div>
    </div>

    {% if total_questions > 0 %}
    <!-- Practice Content -->
    <div class="practice-content {% if not first_question.stimulus or first_question.stimulus|length < 3 %}no-stimulus{% endif %}">
        <!-- Stimulus/Passage Panel -->
        <div class="stimulus-panel font-lato" id="stimulus-panel">
            <div id="stimulus-content">
                {% if first_question.stimulus %}
                    {{ first_question.stimulus|safe }}
                {% else %}
                    <p class="text-sm text-gray-500">No additional context for this question.</p>
                {% endif %}
            </div>
        </div>

        <!-- Question Panel -->
        <div class="question-panel font-lato" id="question-panel">
            <div class="flex items-center justify-between">
                <span class="question-number" id="question-number">1</span>
                <div class="flex items-center gap-3">
                    <button class="mark-toggle-btn" id="mark-for-review" onclick="toggleMarkForReview()">
                        <i class="fas fa-flag"></i>
                        <span id="mark-btn-text">Mark</span>
                    </button>
                    <button class="mastered-toggle-btn" id="mastered-btn" onclick="toggleMastered()">
                        <i class="fas fa-check-circle"></i>
                        <span id="mastered-btn-text">Mastered</span>
                    </button>
                    <button class="nav-btn" id="show-explanation-btn" onclick="toggleExplanation()" style="display: none; background: #fdcc4c; color: #262632; padding: 0.375rem 0.75rem; font-size: 0.75rem;">
                        <i class="fas fa-lightbulb"></i> Show Explanation
                    </button>
                </div>
            </div>

            <div class="question-text" id="question-stem">
                {{ first_question.stem|safe }}
            </div>

            <div class="answer-options" id="answer-options">
                {% if first_question.mcq_option_list %}
                    {% for key, value in first_question.mcq_option_list.items %}
                    <div class="answer-option" data-answer="{{ key }}" onclick="selectAnswer('{{ key }}')">
                        <span class="option-label">{{ key }}:</span>
                        <span class="option-text">{{ value|safe }}</span>
                        <button class="strikethrough-btn" onclick="toggleStrikethrough(event, this)">
                            <i class="fas fa-ban"></i>
                        </button>
                    </div>
                    {% endfor %}
                {% endif %}
            </div>

            <!-- Explanation Panel (hidden initially) -->
            <div class="explanation-panel font-lato" id="explanation-panel">
                <div class="explanation-title">Explanation</div>
                <div class="explanation-text" id="explanation-text"></div>
            </div>
        </div>
    </div>

    <!-- Footer with Navigation -->
    <div class="practice-footer">
        <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
            <button class="question-counter" id="question-counter" onclick="openQuestionMap()" style="cursor: pointer;">
                <i class="fas fa-list-ol"></i> <span>Questions</span> <span id="current-index">1</span>/<span id="total-count">{{ total_questions }}</span>
            </button>
            <!-- Attempt Info Badge -->
            <div class="attempt-info-badge" id="attemptInfo" style="display: none;">
                <i class="fas fa-history"></i>
                <span id="attemptCount">0</span> <span class="attempts-text">attempts</span>
                <span id="lastAttemptTime" class="last-attempt-time" style="margin-left: 0.5rem;"></span>
            </div>
            <button class="history-btn" id="history-btn" onclick="showAttemptHistory()" title="View attempt history" style="display: none;">
                <i class="fas fa-history"></i>
                <span class="history-btn-text">History</span>
                <span class="history-badge" id="historyBadge">0</span>
            </button>
        </div>
        <div class="navigation-buttons">
            <button class="nav-btn end-btn" onclick="endPractice()" style="background: #ef4444; color: white;">
                <i class="fas fa-stop-circle"></i> <span id="end-btn-text">End Practice</span>
            </button>
            <button class="nav-btn" id="check-answer-btn" onclick="checkAnswer()" style="background: #10b981; color: white;" disabled>
                <i class="fas fa-check-circle"></i> <span id="check-btn-text">Check</span>
            </button>
            <div class="action-buttons-group">
                <button class="nav-btn back" id="back-btn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-arrow-left"></i> <span class="hide-on-mobile">Back</span>
                </button>
                <button class="nav-btn next" id="next-btn" onclick="nextQuestion()">
                    <span id="next-btn-text" class="hide-on-mobile">Next</span> <i class="fas fa-arrow-right"></i>
                </button>
            </div>
        </div>
    </div>

    {% else %}
    <div class="empty-state">
        <h3>No Questions Available</h3>
        <p>There are no questions matching your current filters. Try adjusting your selection.</p>
    </div>
    {% endif %}

    <!-- Question Map Modal -->
    <div class="question-map-modal" id="questionMapModal">
        <div class="question-map-content">
            <div class="question-map-header">
                <h3><i class="fas fa-map"></i> Question Map</h3>
                <button class="close-modal-btn" onclick="closeQuestionMap()"><i class="fas fa-times"></i></button>
            </div>
            
            <div class="question-map-legend">
                <div class="legend-item">
                    <div class="legend-box current"></div>
                    <span>Current</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box answered"></div>
                    <span>Mastered</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box tried"></div>
                    <span>Tried</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box not-tried"></div>
                    <span>Not Tried</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box marked"></div>
                    <span>Marked</span>
                </div>
            </div>
            
            <div class="question-map-grid" id="questionMapGrid">
                <!-- Questions will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Alert Modal -->
    <div class="alert-modal" id="alertModal">
        <div class="alert-modal-content">
            <div class="alert-modal-message" id="alertMessage"></div>
            <div class="alert-modal-buttons" id="alertButtons"></div>
        </div>
    </div>

    <!-- Navigation Warning Tooltip -->
    <div class="nav-warning-tooltip" id="navWarningTooltip">
        <i class="fas fa-exclamation-triangle"></i> You have not checked your answer. Click again to proceed.
    </div>

    <!-- Explanation Modal -->
    <div class="alert-modal" id="explanationModal">
        <div class="alert-modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 2px solid #e5e7eb;">
                <h3 style="font-size: 1.125rem; font-weight: 700; color: #262632;"><i class="fas fa-lightbulb"></i> Explanation</h3>
                <button class="close-modal-btn" onclick="closeExplanationModal()"><i class="fas fa-times"></i></button>
            </div>
            <div id="explanation-modal-text" style="font-size: 1.125rem; line-height: 1.8; color: #374151; font-family: 'Noto Serif', serif;"></div>
        </div>
    </div>

    <!-- Attempt History Modal -->
    <div class="attempt-history-modal" id="attemptHistoryModal">
        <div class="attempt-history-content">
            <div class="attempt-history-header">
                <h3><i class="fas fa-history"></i> Attempt History</h3>
                <button class="close-modal-btn" onclick="closeAttemptHistory()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="attempt-history-list" id="attemptHistoryList">
                <!-- Attempts will be populated by JavaScript -->
            </div>
        </div>
    </div>
</div>

<script>
// Global state
const questionIds = {{ question_ids|safe }};
let currentIndex = 0;
let selectedAnswer = null;
let userAnswers = {};
let answeredCorrectly = {}; // Track which questions were answered correctly
let markedForReview = new Set();
let masteredQuestions = new Set(); // Track which questions are mastered
let strikethroughOptions = {};
let answerChecked = {}; // Track which questions have been checked
let questionAttemptCounts = {}; // Track attempt count for each question from backend
let navigationWarningShown = false; // Track if warning tooltip was shown

// Session tracking
const sessionId = '{{ session_id }}';
let questionStartTime = Date.now();

// Timer - counts up from 0 for each question
let timerSeconds = 0;
let timerInterval = null;
let timerVisible = true;

function startTimer() {
    // Clear any existing timer
    if (timerInterval) {
        clearInterval(timerInterval);
    }
    
    // Reset to 0
    timerSeconds = 0;
    updateTimerDisplay();
    
    // Start counting up
    timerInterval = setInterval(() => {
        timerSeconds++;
        updateTimerDisplay();
    }, 1000);
}

function stopTimer() {
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
}

function updateTimerDisplay() {
    const minutes = Math.floor(timerSeconds / 60);
    const seconds = timerSeconds % 60;
    const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    document.getElementById('timer').textContent = display;
}

function toggleTimer() {
    timerVisible = !timerVisible;
    const timerElement = document.getElementById('timer');
    const btn = event.target.closest('button');
    const btnText = document.getElementById('timer-btn-text');
    const btnIcon = btn ? btn.querySelector('i') : null;
    
    if (btnText && btnIcon) {
        if (timerVisible) {
            timerElement.style.display = 'block';
            btnText.textContent = 'Hide';
            btnIcon.className = 'fas fa-eye-slash';
        } else {
            timerElement.style.display = 'none';
            btnText.textContent = 'Show';
            btnIcon.className = 'fas fa-eye';
        }
    }
}

function updateAttemptInfo(question) {
    const attemptInfo = document.getElementById('attemptInfo');
    const attemptCount = document.getElementById('attemptCount');
    const lastAttemptTime = document.getElementById('lastAttemptTime');
    const historyBtn = document.getElementById('history-btn');
    const historyBadge = document.getElementById('historyBadge');
    
    // Store all attempts globally for the history modal
    window.currentQuestionAttempts = question.all_attempts || [];
    
    if (question.attempt_count > 0) {
        attemptInfo.style.display = 'inline-flex';
        attemptCount.textContent = question.attempt_count;
        
        // Show and update history button in footer
        if (historyBtn && historyBadge) {
            historyBtn.style.display = 'inline-flex';
            historyBadge.textContent = question.attempt_count;
        }
        
        if (question.last_attempt) {
            const lastAttempt = question.last_attempt;
            const attemptDate = new Date(lastAttempt.answered_at);
            const now = new Date();
            const diffMs = now - attemptDate;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMins / 60);
            const diffDays = Math.floor(diffHours / 24);
            
            let timeAgo = '';
            if (diffDays > 0) {
                timeAgo = `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
            } else if (diffHours > 0) {
                timeAgo = `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
            } else if (diffMins > 0) {
                timeAgo = `${diffMins} min${diffMins > 1 ? 's' : ''} ago`;
            } else {
                timeAgo = 'just now';
            }
            
            const statusClass = lastAttempt.is_correct ? 'correct' : 'incorrect';
            const statusIcon = lastAttempt.is_correct ? '✓' : '✗';
            const statusText = lastAttempt.is_correct ? 'Correct' : 'Incorrect';
            
            lastAttemptTime.innerHTML = `
                • Last: ${timeAgo}
                <span class="last-attempt-badge ${statusClass}">
                    ${statusIcon} ${statusText} (${lastAttempt.answer})
                </span>
            `;
        } else {
            lastAttemptTime.textContent = '';
        }
    } else {
        attemptInfo.style.display = 'none';
        window.currentQuestionAttempts = [];
        
        // Hide history button in footer
        if (historyBtn) {
            historyBtn.style.display = 'none';
        }
    }
}

function showAttemptHistory() {
    const modal = document.getElementById('attemptHistoryModal');
    const listContainer = document.getElementById('attemptHistoryList');
    
    if (!window.currentQuestionAttempts || window.currentQuestionAttempts.length === 0) {
        listContainer.innerHTML = '<p style="text-align: center; color: #6b7280; padding: 2rem;">No attempts yet.</p>';
        modal.classList.add('show');
        return;
    }
    
    // Get only the last 5 attempts (most recent)
    const recentAttempts = window.currentQuestionAttempts.slice(0, 5);
    
    // Sort attempts from oldest to newest for better chronological view
    const sortedAttempts = [...recentAttempts].reverse();
    
    const attemptsHtml = sortedAttempts.map((attempt, index) => {
        const attemptDate = new Date(attempt.answered_at);
        const now = new Date();
        const diffMs = now - attemptDate;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMins / 60);
        const diffDays = Math.floor(diffHours / 24);
        
        let timeAgo = '';
        if (diffDays > 0) {
            timeAgo = `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
        } else if (diffHours > 0) {
            timeAgo = `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
        } else if (diffMins > 0) {
            timeAgo = `${diffMins} min${diffMins > 1 ? 's' : ''} ago`;
        } else {
            timeAgo = 'just now';
        }
        
        const statusClass = attempt.is_correct ? 'correct' : 'incorrect';
        const statusIcon = attempt.is_correct ? '✓' : '✗';
        const statusText = attempt.is_correct ? 'Correct' : 'Incorrect';
        
        return `
            <div class="attempt-item">
                <div class="attempt-number">#${index + 1}</div>
                <div class="attempt-details">
                    <div class="attempt-answer ${statusClass}">Answer: ${attempt.answer}</div>
                    <div class="attempt-time">
                        ${timeAgo} • ${attempt.time_taken}s
                    </div>
                </div>
                <div class="attempt-status-badge ${statusClass}">
                    ${statusIcon} ${statusText}
                </div>
            </div>
        `;
    }).join('');
    
    listContainer.innerHTML = attemptsHtml;
    modal.classList.add('show');
}

function closeAttemptHistory() {
    const modal = document.getElementById('attemptHistoryModal');
    modal.classList.remove('show');
}

// Close modal when clicking outside
document.addEventListener('click', function(e) {
    const modal = document.getElementById('attemptHistoryModal');
    if (e.target === modal) {
        closeAttemptHistory();
    }
});

function toggleAnnotate() {
    showAlert('Annotation feature coming soon!');
}

function toggleQuestionDetails() {
    const modal = document.getElementById('question-details-modal');
    modal.classList.toggle('show');
}

function toggleExplanation() {
    const explanationModal = document.getElementById('explanationModal');
    explanationModal.classList.add('show');
}

function closeExplanationModal() {
    const explanationModal = document.getElementById('explanationModal');
    explanationModal.classList.remove('show');
}

// Close explanation modal when clicking outside
document.addEventListener('click', function(e) {
    const modal = document.getElementById('explanationModal');
    if (e.target === modal) {
        closeExplanationModal();
    }
});

// Navigation Warning Tooltip
function showNavigationWarning() {
    const tooltip = document.getElementById('navWarningTooltip');
    tooltip.classList.add('show');
    
    // Hide after 3 seconds
    setTimeout(() => {
        tooltip.classList.remove('show');
    }, 3000);
}

// Alert Modal Functions
function showAlert(message, onConfirm = null) {
    const modal = document.getElementById('alertModal');
    const messageEl = document.getElementById('alertMessage');
    const buttonsEl = document.getElementById('alertButtons');
    
    messageEl.textContent = message;
    buttonsEl.innerHTML = '';
    
    if (onConfirm) {
        // Confirmation dialog with Cancel and OK buttons
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'alert-modal-btn cancel';
        cancelBtn.textContent = 'Cancel';
        cancelBtn.onclick = () => closeAlert();
        
        const confirmBtn = document.createElement('button');
        confirmBtn.className = 'alert-modal-btn confirm';
        confirmBtn.textContent = 'OK';
        confirmBtn.onclick = () => {
            closeAlert();
            onConfirm();
        };
        
        buttonsEl.appendChild(cancelBtn);
        buttonsEl.appendChild(confirmBtn);
    } else {
        // Simple alert with OK button
        const okBtn = document.createElement('button');
        okBtn.className = 'alert-modal-btn ok';
        okBtn.textContent = 'OK';
        okBtn.onclick = () => closeAlert();
        
        buttonsEl.appendChild(okBtn);
    }
    
    modal.classList.add('show');
}

function closeAlert() {
    const modal = document.getElementById('alertModal');
    modal.classList.remove('show');
}

// Question Map Modal Functions
function openQuestionMap() {
    const modal = document.getElementById('questionMapModal');
    modal.classList.add('show');
    renderQuestionMap();
}

function closeQuestionMap() {
    const modal = document.getElementById('questionMapModal');
    modal.classList.remove('show');
}

function renderQuestionMap() {
    const grid = document.getElementById('questionMapGrid');
    grid.innerHTML = '';
    
    questionIds.forEach((questionId, index) => {
        const item = document.createElement('div');
        item.className = 'question-map-item';
        item.textContent = index + 1;
        
        // Add status classes - priority order matters
        if (index === currentIndex) {
            // Currently viewing this question
            item.classList.add('current');
        } else if (masteredQuestions.has(questionId)) {
            // Question is mastered (from backend or first-attempt correct)
            item.classList.add('mastered');
        } else if (answeredCorrectly[questionId] === true) {
            // Question was answered correctly in this session (but not yet mastered)
            item.classList.add('answered');
        } else if (questionAttemptCounts[questionId] > 0) {
            // Question has been attempted before (from backend history)
            item.classList.add('tried');
        } else if (userAnswers[questionId] !== undefined || answerChecked[questionId]) {
            // Question was attempted in this session
            item.classList.add('tried');
        }
        // If none of above, it stays as not-tried (default white background)
        
        // Check if marked for review
        if (markedForReview.has(questionId)) {
            item.classList.add('marked');
        }
        
        // Click handler to jump to question
        item.onclick = () => {
            closeQuestionMap();
            loadQuestion(index);
        };
        
        grid.appendChild(item);
    });
}

// Close modal when clicking outside
document.addEventListener('click', function(e) {
    const modal = document.getElementById('questionMapModal');
    if (e.target === modal) {
        closeQuestionMap();
    }
});

// Question navigation
function selectAnswer(answer) {
    selectedAnswer = answer;
    
    // Update UI
    document.querySelectorAll('.answer-option').forEach(option => {
        option.classList.remove('selected');
    });
    
    event.currentTarget.classList.add('selected');
    
    // Save answer
    const currentQuestionId = questionIds[currentIndex];
    userAnswers[currentQuestionId] = answer;
    
    // Enable Check Answer button
    document.getElementById('check-answer-btn').disabled = false;
}

// Check answer with backend validation
async function checkAnswer() {
    if (!selectedAnswer) {
        showAlert('Please select an answer first!');
        return;
    }
    
    const currentQuestionId = questionIds[currentIndex];
    const checkBtn = document.getElementById('check-answer-btn');
    
    // Calculate time taken for this question
    const timeTaken = Math.floor((Date.now() - questionStartTime) / 1000);
    
    // Disable button during check
    checkBtn.disabled = true;
    const checkBtnText = document.getElementById('check-btn-text');
    const checkBtnIcon = checkBtn.querySelector('i');
    if (checkBtnText) {
        checkBtnText.textContent = 'Checking...';
    }
    if (checkBtnIcon) {
        checkBtnIcon.className = 'fas fa-spinner fa-spin';
    }
    
    try {
        const response = await fetch(`/practice/api/check-answer/${currentQuestionId}/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                answer: selectedAnswer,
                session_id: sessionId,
                time_taken: timeTaken
            })
        });
        
        const data = await response.json();
        
        // Track if answer was correct and checked
        answeredCorrectly[currentQuestionId] = data.is_correct;
        answerChecked[currentQuestionId] = true;
        
        // Update UI based on correctness
        document.querySelectorAll('.answer-option').forEach(option => {
            const optionAnswer = option.dataset.answer;
            
            if (data.is_correct && optionAnswer === selectedAnswer) {
                option.classList.add('correct');
            } else if (!data.is_correct && optionAnswer === selectedAnswer) {
                option.classList.add('incorrect');
            }
            
            // Show correct answer if user was wrong
            if (!data.is_correct && optionAnswer === data.correct_answer) {
                option.classList.add('correct');
            }
        });
        
        // Store explanation in modal but don't show it yet
        if (data.explanation) {
            document.getElementById('explanation-modal-text').innerHTML = data.explanation;
            
            // Render MathJax in explanation modal
            if (window.MathJax) {
                MathJax.typesetPromise([document.getElementById('explanation-modal-text')]);
            }
            
            // Show the "Show Explanation" button
            document.getElementById('show-explanation-btn').style.display = 'inline-flex';
        }
        
        // Change button text with icon
        const checkBtnText = document.getElementById('check-btn-text');
        const checkBtnIcon = checkBtn.querySelector('i');
        if (checkBtnText && checkBtnIcon) {
            if (data.is_correct) {
                checkBtnText.textContent = 'Correct!';
                checkBtnIcon.className = 'fas fa-check-circle';
                checkBtn.style.background = '#10b981';
            } else {
                checkBtnText.textContent = 'Incorrect';
                checkBtnIcon.className = 'fas fa-times-circle';
                checkBtn.style.background = '#ef4444';
            }
        }
        
    } catch (error) {
        console.error('Error checking answer:', error);
        showAlert('Failed to check answer. Please try again.');
        checkBtn.disabled = false;
        const checkBtnText = document.getElementById('check-btn-text');
        const checkBtnIcon = checkBtn.querySelector('i');
        if (checkBtnText) {
            checkBtnText.textContent = 'Check';
        }
        if (checkBtnIcon) {
            checkBtnIcon.className = 'fas fa-check-circle';
        }
        checkBtn.style.background = '#10b981';
    }
}

// Helper function to get CSRF token
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

function toggleStrikethrough(e, button) {
    e.stopPropagation();
    
    const option = button.closest('.answer-option');
    const answer = option.dataset.answer;
    const currentQuestionId = questionIds[currentIndex];
    
    if (!strikethroughOptions[currentQuestionId]) {
        strikethroughOptions[currentQuestionId] = new Set();
    }
    
    if (strikethroughOptions[currentQuestionId].has(answer)) {
        strikethroughOptions[currentQuestionId].delete(answer);
        option.style.opacity = '1';
        option.style.textDecoration = 'none';
        button.classList.remove('active');
    } else {
        strikethroughOptions[currentQuestionId].add(answer);
        option.style.opacity = '0.5';
        option.style.textDecoration = 'line-through';
        button.classList.add('active');
    }
}

async function loadQuestion(index) {
    if (index < 0 || index >= questionIds.length) return;
    
    currentIndex = index;
    const questionId = questionIds[index];
    
    // Update URL with question ID
    const url = new URL(window.location);
    url.searchParams.set('question', questionId);
    window.history.pushState({}, '', url);
    
    // Show loading
    document.getElementById('stimulus-content').innerHTML = '<div class="loading">Loading...</div>';
    document.getElementById('question-stem').innerHTML = '<div class="loading">Loading...</div>';
    document.getElementById('answer-options').innerHTML = '<div class="loading">Loading...</div>';
    
    try {
        const response = await fetch(`/practice/api/question/${questionId}/`);
        const question = await response.json();
        
        // Update domain and skill badges in modal
        document.getElementById('modal-domain-code').textContent = question.domain_code;
        document.getElementById('modal-domain-name').textContent = question.domain_name;
        document.getElementById('modal-skill-code').textContent = question.skill_code;
        document.getElementById('modal-skill-name').textContent = question.skill_name;
        document.getElementById('modal-question-number').textContent = `${index + 1} of ${questionIds.length}`;
        
        // Update stimulus and toggle layout
        const practiceContent = document.querySelector('.practice-content');
        const hasStimulus = question.stimulus && question.stimulus.trim().length > 2;
        
        if (hasStimulus) {
            document.getElementById('stimulus-content').innerHTML = question.stimulus;
            practiceContent.classList.remove('no-stimulus');
        } else {
            document.getElementById('stimulus-content').innerHTML = '<p class="text-sm text-gray-500">No additional context for this question.</p>';
            practiceContent.classList.add('no-stimulus');
        }
        
        // Update question stem
        document.getElementById('question-stem').innerHTML = question.stem;
        
        // Update answer options
        const optionsHtml = Object.entries(question.mcq_options || {}).map(([key, value]) => `
            <div class="answer-option ${userAnswers[questionId] === key ? 'selected' : ''}" 
                 data-answer="${key}" 
                 onclick="selectAnswer('${key}')"
                 style="${strikethroughOptions[questionId]?.has(key) ? 'opacity: 0.5; text-decoration: line-through;' : ''}">
                <span class="option-label">${key}:</span>
                <span class="option-text">${value}</span>
                <button class="strikethrough-btn ${strikethroughOptions[questionId]?.has(key) ? 'active' : ''}" 
                        onclick="toggleStrikethrough(event, this)">
                    <i class="fas fa-ban"></i>
                </button>
            </div>
        `).join('');
        
        document.getElementById('answer-options').innerHTML = optionsHtml;
        
        // Render MathJax for mathematical expressions
        if (window.MathJax) {
            MathJax.typesetPromise([
                document.getElementById('stimulus-content'),
                document.getElementById('question-stem'),
                document.getElementById('answer-options')
            ]).catch((err) => console.log('MathJax error:', err));
        }
        
        // Update question number
        document.getElementById('question-number').textContent = index + 1;
        document.getElementById('current-index').textContent = index + 1;
        
        // Update mark for review button
        const markBtn = document.getElementById('mark-for-review');
        const markBtnText = document.getElementById('mark-btn-text');
        if (markedForReview.has(questionId)) {
            markBtn.classList.add('marked');
            markBtnText.textContent = 'Marked';
        } else {
            markBtn.classList.remove('marked');
            markBtnText.textContent = 'Mark';
        }
        
        // Update mastered button
        const masteredBtn = document.getElementById('mastered-btn');
        const masteredBtnText = document.getElementById('mastered-btn-text');
        
        // Update button state based on mastered status
        if (masteredQuestions.has(questionId)) {
            masteredBtn.classList.add('mastered');
            masteredBtnText.textContent = 'Mastered';
        } else {
            masteredBtn.classList.remove('mastered');
            masteredBtnText.textContent = 'Master';
        }
        
        // Disable/enable button based on can_toggle_mastered
        if (question.can_toggle_mastered === false) {
            masteredBtn.disabled = true;
            masteredBtn.style.opacity = '0.5';
            masteredBtn.style.cursor = 'not-allowed';
            masteredBtn.title = 'You can only mark as mastered after getting it wrong first and then correct.';
        } else {
            masteredBtn.disabled = false;
            masteredBtn.style.opacity = '1';
            masteredBtn.style.cursor = 'pointer';
            
            if (question.is_auto_mastered) {
                masteredBtn.title = 'Auto-mastered (correct on first attempt). Click to unmark.';
            } else {
                masteredBtn.title = 'Mark this question as mastered';
            }
        }
        
        // Store attempt count for this question
        if (question.attempt_count > 0) {
            questionAttemptCounts[questionId] = question.attempt_count;
        }
        
        // Update attempt information
        updateAttemptInfo(question);
        
        // Update navigation buttons
        document.getElementById('back-btn').disabled = index === 0;
        const nextBtn = document.getElementById('next-btn');
        const nextBtnText = document.getElementById('next-btn-text');
        const nextBtnIcon = nextBtn.querySelector('i');
        
        if (nextBtnText && nextBtnIcon) {
            if (index === questionIds.length - 1) {
                // Last question - change Next to Finish
                nextBtnText.textContent = 'Finish';
                nextBtnIcon.className = 'fas fa-flag-checkered';
                nextBtn.disabled = false;
            } else {
                nextBtnText.textContent = 'Next';
                nextBtnIcon.className = 'fas fa-arrow-right';
                nextBtn.disabled = false;
            }
        }
        
        // Reset Check Answer button
        const checkBtn = document.getElementById('check-answer-btn');
        const checkBtnText = document.getElementById('check-btn-text');
        const checkBtnIcon = checkBtn.querySelector('i');
        checkBtn.disabled = !userAnswers[questionId];
        if (checkBtnText && checkBtnIcon) {
            checkBtnText.textContent = 'Check';
            checkBtnIcon.className = 'fas fa-check-circle';
            checkBtn.style.background = '#10b981';
        }
        
        // Remove correct/incorrect classes from all options
        document.querySelectorAll('.answer-option').forEach(option => {
            option.classList.remove('correct', 'incorrect');
        });
        
        // Hide explanation and reset button
        document.getElementById('explanation-panel').classList.remove('show');
        closeExplanationModal(); // Close modal if open
        const showExplanationBtn = document.getElementById('show-explanation-btn');
        showExplanationBtn.style.display = 'none';
        document.getElementById('explanation-modal-text').innerHTML = ''; // Clear modal content
        
        // Reset question start time for timing
        questionStartTime = Date.now();
        
        // Start fresh timer for this question
        startTimer();
        
        // Restore selected answer
        selectedAnswer = userAnswers[questionId] || null;
        
        // Reset navigation warning flag
        navigationWarningShown = false;
        
    } catch (error) {
        console.error('Error loading question:', error);
        showAlert('Error loading question. Please try again.');
    }
}

function previousQuestion() {
    const currentQuestionId = questionIds[currentIndex];
    
    // Check if user selected an answer but hasn't checked it
    if (userAnswers[currentQuestionId] && !answerChecked[currentQuestionId]) {
        if (!navigationWarningShown) {
            // First click - show warning tooltip
            showNavigationWarning();
            navigationWarningShown = true;
            return;
        }
        // Second click - allow navigation and reset warning flag
        navigationWarningShown = false;
    }
    
    if (currentIndex > 0) {
        loadQuestion(currentIndex - 1);
    }
}

function nextQuestion() {
    const currentQuestionId = questionIds[currentIndex];
    
    // Check if user selected an answer but hasn't checked it
    if (userAnswers[currentQuestionId] && !answerChecked[currentQuestionId]) {
        if (!navigationWarningShown) {
            // First click - show warning tooltip
            showNavigationWarning();
            navigationWarningShown = true;
            return;
        }
        // Second click - allow navigation and reset warning flag
        navigationWarningShown = false;
    }
    
    if (currentIndex < questionIds.length - 1) {
        loadQuestion(currentIndex + 1);
    } else {
        // Last question - show finish option
        showAlert(
            'You have reached the last question. Do you want to finish the practice session and view your results?',
            () => endPractice()
        );
    }
}

// End practice session
async function endPractice() {
    // Create a promise-based confirmation
    return new Promise((resolve) => {
        showAlert(
            'Are you sure you want to end this practice session? You will see a detailed report of your performance.',
            async () => {
                try {
                    await performEndPractice();
                    resolve();
                } catch (error) {
                    resolve();
                }
            }
        );
    });
}

// Actual end practice logic
async function performEndPractice() {
    try {
        const response = await fetch('/practice/api/end-practice/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                session_id: sessionId
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Add delta_earned to redirect URL if present
            let redirectUrl = data.redirect_url;
            if (data.delta_earned) {
                redirectUrl += (redirectUrl.includes('?') ? '&' : '?') + 'delta_earned=' + data.delta_earned;
            }
            window.location.href = redirectUrl;
        } else {
            showAlert('Failed to end practice: ' + data.error);
        }
    } catch (error) {
        console.error('Error ending practice:', error);
        showAlert('Failed to end practice. Please try again.');
    }
}

async function showExplanation() {
    const questionId = questionIds[currentIndex];
    
    try {
        const response = await fetch(`/practice/api/question/${questionId}/`);
        const question = await response.json();
        
        const explanationPanel = document.getElementById('explanation-panel');
        const explanationText = document.getElementById('explanation-text');
        
        explanationText.innerHTML = question.explanation || 'No explanation available.';
        explanationPanel.classList.add('show');
        
        // Render MathJax for explanation
        if (window.MathJax) {
            MathJax.typesetPromise([explanationText]).catch((err) => console.log('MathJax error:', err));
        }
    } catch (error) {
        console.error('Error loading explanation:', error);
    }
}

// Mark for review - toggle function that saves to backend
async function toggleMarkForReview() {
    const currentQuestionId = questionIds[currentIndex];
    const markBtn = document.getElementById('mark-for-review');
    const markBtnText = document.getElementById('mark-btn-text');
    
    try {
        const response = await fetch('/practice/api/mark-question/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                question_id: currentQuestionId
            })
        });
        
        const data = await response.json();
        
        if (data.marked) {
            markedForReview.add(currentQuestionId);
            markBtn.classList.add('marked');
            markBtnText.textContent = 'Marked';
        } else {
            markedForReview.delete(currentQuestionId);
            markBtn.classList.remove('marked');
            markBtnText.textContent = 'Mark';
        }
    } catch (error) {
        console.error('Error marking question:', error);
        // Revert button state on error
        if (markBtn.classList.contains('marked')) {
            markBtn.classList.remove('marked');
            markBtnText.textContent = 'Mark';
        } else {
            markBtn.classList.add('marked');
            markBtnText.textContent = 'Marked';
        }
    }
}

// Toggle mastered status - saves to backend
async function toggleMastered() {
    const currentQuestionId = questionIds[currentIndex];
    const masteredBtn = document.getElementById('mastered-btn');
    const masteredBtnText = document.getElementById('mastered-btn-text');
    
    // Check if button is disabled
    if (masteredBtn.disabled) {
        showAlert('You can only mark as mastered after getting it wrong first and then correct.');
        return;
    }
    
    try {
        const response = await fetch('/practice/api/master-question/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                question_id: currentQuestionId
            })
        });
        
        const data = await response.json();
        
        // Check for error
        if (data.error || data.success === false) {
            showAlert(data.error || 'Unable to mark as mastered.');
            return;
        }
        
        if (data.mastered) {
            masteredQuestions.add(currentQuestionId);
            masteredBtn.classList.add('mastered');
            masteredBtnText.textContent = 'Mastered';
        } else {
            masteredQuestions.delete(currentQuestionId);
            masteredBtn.classList.remove('mastered');
            masteredBtnText.textContent = 'Master';
        }
    } catch (error) {
        console.error('Error toggling mastered status:', error);
        showAlert('Failed to update mastered status. Please try again.');
    }
}

// Load marked questions on page load
async function loadMarkedQuestions() {
    try {
        const response = await fetch('/practice/api/marked-questions/');
        const data = await response.json();
        
        if (data.marked_question_ids) {
            markedForReview = new Set(data.marked_question_ids);
        }
    } catch (error) {
        console.error('Error loading marked questions:', error);
    }
}

// Load mastered questions on page load
async function loadMasteredQuestions() {
    try {
        const response = await fetch('/practice/api/mastered-questions/');
        const data = await response.json();
        
        if (data.mastered_question_ids) {
            masteredQuestions = new Set(data.mastered_question_ids);
        }
    } catch (error) {
        console.error('Error loading mastered questions:', error);
    }
}

async function loadAttemptedQuestions() {
    try {
        const response = await fetch('/practice/api/attempted-questions/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                question_ids: questionIds
            })
        });
        const data = await response.json();
        
        if (data.attempt_counts) {
            // Store attempt counts for all questions
            questionAttemptCounts = data.attempt_counts;
        }
    } catch (error) {
        console.error('Error loading attempted questions:', error);
    }
}

// Load session answers on page load
async function loadSessionAnswers() {
    try {
        const response = await fetch(`/practice/api/session-answers/${sessionId}/`);
        const data = await response.json();
        
        if (data.answers) {
            // Populate userAnswers object with previous answers
            Object.entries(data.answers).forEach(([questionId, answerData]) => {
                userAnswers[questionId] = answerData.answer;
                answeredCorrectly[questionId] = answerData.is_correct;
            });
        }
    } catch (error) {
        console.error('Error loading session answers:', error);
    }
}

// Initialize on DOM ready
document.addEventListener('DOMContentLoaded', async function() {
    // Load marked questions from backend
    await loadMarkedQuestions();
    
    // Load mastered questions from backend
    await loadMasteredQuestions();
    
    // Load attempted questions (attempt counts for all questions)
    await loadAttemptedQuestions();
    
    // Load session answers from backend (for resumed sessions)
    await loadSessionAnswers();
    
    // Check if there's a question ID in the URL
    const urlParams = new URLSearchParams(window.location.search);
    const questionIdParam = urlParams.get('question');
    let initialIndex = {{ initial_index|default:0 }};  // Use backend-calculated index
    
    if (questionIdParam && initialIndex === 0) {
        // Fallback: try to find question in array if backend didn't set index
        const foundIndex = questionIds.findIndex(id => id === questionIdParam);
        console.log('Looking for question:', questionIdParam);
        console.log('Found at index:', foundIndex);
        console.log('Question IDs array length:', questionIds.length);
        if (foundIndex !== -1) {
            initialIndex = foundIndex;
        } else {
            console.warn('Question not found in question_ids array');
        }
    }
    
    console.log('Starting at index:', initialIndex);
    // Load the initial question (this will start the timer)
    loadQuestion(initialIndex);
    
    // Render MathJax on initial page load
    if (window.MathJax) {
        MathJax.typesetPromise().catch((err) => console.log('MathJax initial render error:', err));
    }
});

// Keyboard navigation
document.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowLeft') {
        previousQuestion();
    } else if (e.key === 'ArrowRight') {
        nextQuestion();
    } else if (e.key >= 'A' && e.key <= 'D') {
        selectAnswer(e.key.toUpperCase());
    }
});

// Handle browser back/forward buttons
window.addEventListener('popstate', function(e) {
    const urlParams = new URLSearchParams(window.location.search);
    const questionIdParam = urlParams.get('question');
    
    if (questionIdParam) {
        const foundIndex = questionIds.findIndex(id => id === questionIdParam);
        if (foundIndex !== -1) {
            loadQuestion(foundIndex);
        }
    }
});
</script>
{% endblock %}
