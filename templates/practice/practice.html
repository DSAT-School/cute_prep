{% extends "base_dashboard.html" %}
{% load static %}

{% block title %}Practice - DSAT SCHOOL{% endblock %}

{% block extra_css %}
<style>
    /* Practice Interface Styles */
    .practice-container {
        max-width: 1920px;
        margin: 0 auto;
        padding: 1.5rem 3rem;
    }

    .practice-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1rem;
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        margin-bottom: 1rem;
    }

    .timer {
        font-size: 1.25rem;
        font-weight: 600;
        color: #262632;
    }

    .skill-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.375rem 0.75rem;
        background: #f3e8ff;
        border-radius: 6px;
        font-size: 0.75rem;
        font-weight: 600;
        color: #7c3aed;
    }

    .domain-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.375rem 0.75rem;
        background: #dbeafe;
        border-radius: 6px;
        font-size: 0.75rem;
        font-weight: 600;
        color: #1e40af;
    }

    .hide-timer-btn {
        padding: 0.375rem 0.75rem;
        font-size: 0.875rem;
        background: white;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .hide-timer-btn:hover {
        background: #f3f4f6;
    }

    .annotate-btn {
        padding: 0.375rem 0.75rem;
        font-size: 0.875rem;
        background: white;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .annotate-btn:hover {
        background: #f3f4f6;
    }

    .practice-content {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        margin-bottom: 1rem;
    }

    .stimulus-panel,
    .question-panel {
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 2rem;
        height: calc(100vh - 220px);
        overflow-y: auto;
        font-size: 0.95rem;
        line-height: 1.7;
    }

    .stimulus-panel p,
    .question-panel p {
        margin-bottom: 1rem;
    }

    .stimulus-panel strong,
    .question-panel strong {
        font-weight: 600;
        color: #1f2937;
    }

    .question-number {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 2rem;
        height: 2rem;
        background: #262632;
        color: white;
        font-weight: 600;
        font-size: 0.875rem;
        border-radius: 4px;
        margin-bottom: 1rem;
    }

    .mark-review {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.875rem;
        color: #6b7280;
        margin-bottom: 1rem;
        cursor: pointer;
    }

    .mark-review input[type="checkbox"] {
        width: 1rem;
        height: 1rem;
        cursor: pointer;
    }

    .question-text {
        font-size: 0.875rem;
        line-height: 1.6;
        color: #1f2937;
        margin-bottom: 1.5rem;
    }

    .answer-options {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .answer-option {
        display: flex;
        align-items: center;
        padding: 0.875rem 1rem;
        background: #f9fafb;
        border: 2px solid #e5e7eb;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .answer-option:hover {
        background: #f3f4f6;
        border-color: #9967b9;
    }

    .answer-option.selected {
        background: #f3e8ff;
        border-color: #9967b9;
    }

    .answer-option.correct {
        background: #d1fae5;
        border-color: #10b981;
    }

    .answer-option.incorrect {
        background: #fee2e2;
        border-color: #ef4444;
    }

    .option-label {
        font-weight: 600;
        font-size: 0.875rem;
        color: #262632;
        margin-right: 0.75rem;
        min-width: 1.5rem;
    }

    .option-text {
        font-size: 0.875rem;
        color: #374151;
        flex: 1;
    }

    .strikethrough-btn {
        width: 1.5rem;
        height: 1.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
        background: white;
        border: 1px solid #d1d5db;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.75rem;
        color: #6b7280;
    }

    .strikethrough-btn:hover {
        background: #f3f4f6;
    }

    .strikethrough-btn.active {
        background: #fee2e2;
        border-color: #ef4444;
        color: #dc2626;
    }

    .practice-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem;
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
    }

    .question-counter {
        padding: 0.5rem 1rem;
        background: #262632;
        color: white;
        border-radius: 6px;
        font-size: 0.875rem;
        font-weight: 600;
    }

    .navigation-buttons {
        display: flex;
        gap: 0.75rem;
    }

    .nav-btn {
        padding: 0.625rem 1.5rem;
        font-size: 0.875rem;
        font-weight: 600;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        border: none;
    }

    .nav-btn.back {
        background: #e5e7eb;
        color: #374151;
    }

    .nav-btn.back:hover {
        background: #d1d5db;
    }

    .nav-btn.next {
        background: #3b82f6;
        color: white;
    }

    .nav-btn.next:hover {
        background: #2563eb;
    }

    .nav-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .explanation-panel {
        background: #fef3c7;
        border: 1px solid #fbbf24;
        border-radius: 8px;
        padding: 1rem;
        margin-top: 1rem;
        display: none;
    }

    .explanation-panel.show {
        display: block;
    }

    .explanation-title {
        font-size: 0.875rem;
        font-weight: 600;
        color: #92400e;
        margin-bottom: 0.5rem;
    }

    .explanation-text {
        font-size: 0.875rem;
        line-height: 1.6;
        color: #78350f;
    }

    /* Scrollbar styling */
    .stimulus-panel::-webkit-scrollbar,
    .question-panel::-webkit-scrollbar {
        width: 8px;
    }

    .stimulus-panel::-webkit-scrollbar-track,
    .question-panel::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 4px;
    }

    .stimulus-panel::-webkit-scrollbar-thumb,
    .question-panel::-webkit-scrollbar-thumb {
        background: #9967b9;
        border-radius: 4px;
    }

    .stimulus-panel::-webkit-scrollbar-thumb:hover,
    .question-panel::-webkit-scrollbar-thumb:hover {
        background: #7c4d9a;
    }

    /* Loading state */
    .loading {
        text-align: center;
        padding: 3rem;
        color: #6b7280;
    }

    /* Empty state */
    .empty-state {
        text-align: center;
        padding: 3rem;
        color: #6b7280;
    }

    .empty-state h3 {
        font-size: 1.25rem;
        font-weight: 600;
        color: #262632;
        margin-bottom: 0.5rem;
    }

    .empty-state p {
        font-size: 0.875rem;
        color: #6b7280;
    }

    /* Question Map Modal */
    .question-map-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        align-items: center;
        justify-content: center;
    }

    .question-map-modal.show {
        display: flex;
    }

    .question-map-content {
        background: white;
        border-radius: 12px;
        padding: 1.5rem;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        position: relative;
    }

    .question-map-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        padding-bottom: 1rem;
        border-bottom: 2px solid #e5e7eb;
    }

    .question-map-header h3 {
        font-size: 1.125rem;
        font-weight: 700;
        color: #262632;
    }

    .close-modal-btn {
        background: none;
        border: none;
        font-size: 1.5rem;
        color: #6b7280;
        cursor: pointer;
        padding: 0;
        width: 2rem;
        height: 2rem;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
    }

    .close-modal-btn:hover {
        background: #f3f4f6;
        color: #262632;
    }

    .question-map-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        margin-bottom: 1.5rem;
        padding: 0.75rem;
        background: #f9fafb;
        border-radius: 8px;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.75rem;
        color: #6b7280;
    }

    .legend-box {
        width: 1.5rem;
        height: 1.5rem;
        border-radius: 4px;
        border: 2px solid #e5e7eb;
    }

    .legend-box.current {
        background: #9967b9;
        border-color: #9967b9;
        position: relative;
    }

    .legend-box.current::after {
        content: '✓';
        color: white;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.75rem;
    }

    .legend-box.answered {
        background: #10b981;
        border-color: #10b981;
    }

    .legend-box.tried {
        background: #fbbf24;
        border-color: #fbbf24;
    }

    .legend-box.not-tried {
        background: white;
        border-color: #d1d5db;
    }

    .legend-box.marked {
        background: #8b5cf6;
        border-color: #8b5cf6;
    }

    .question-map-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(3rem, 1fr));
        gap: 0.75rem;
    }

    .question-map-item {
        aspect-ratio: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid #d1d5db;
        border-radius: 6px;
        background: white;
        font-size: 0.875rem;
        font-weight: 600;
        color: #6b7280;
        cursor: pointer;
        transition: all 0.2s;
        position: relative;
    }

    .question-map-item:hover {
        transform: scale(1.05);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .question-map-item.current {
        background: #9967b9;
        border-color: #9967b9;
        color: white;
    }

    .question-map-item.current::after {
        content: '✓';
        position: absolute;
        bottom: 2px;
        right: 2px;
        font-size: 0.625rem;
    }

    .question-map-item.answered {
        background: #10b981;
        border-color: #10b981;
        color: white;
    }

    .question-map-item.tried {
        background: #fbbf24;
        border-color: #fbbf24;
        color: white;
    }

    .question-map-item.marked {
        border-color: #8b5cf6;
        border-width: 3px;
    }

    /* Alert Modal */
    .alert-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 2000;
        align-items: center;
        justify-content: center;
    }

    .alert-modal.show {
        display: flex;
    }

    .alert-modal-content {
        background: white;
        border-radius: 12px;
        padding: 1.5rem;
        max-width: 400px;
        width: 90%;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
    }

    .alert-modal-message {
        font-size: 0.875rem;
        color: #374151;
        margin-bottom: 1.5rem;
        line-height: 1.5;
    }

    .alert-modal-buttons {
        display: flex;
        gap: 0.75rem;
        justify-content: flex-end;
    }

    .alert-modal-btn {
        padding: 0.5rem 1rem;
        border-radius: 6px;
        font-size: 0.875rem;
        font-weight: 600;
        cursor: pointer;
        border: none;
        transition: all 0.2s;
    }

    .alert-modal-btn.cancel {
        background: #f3f4f6;
        color: #374151;
    }

    .alert-modal-btn.cancel:hover {
        background: #e5e7eb;
    }

    .alert-modal-btn.confirm {
        background: #9967b9;
        color: white;
    }

    .alert-modal-btn.confirm:hover {
        background: #7c4d9a;
    }

    .alert-modal-btn.ok {
        background: #9967b9;
        color: white;
    }

    .alert-modal-btn.ok:hover {
        background: #7c4d9a;
    }
</style>
{% endblock %}

{% block content %}
<div class="practice-container">
    <!-- Header with Timer and Controls -->
    <div class="practice-header">
        <div class="flex items-center gap-3">
            <div class="timer" id="timer">0:00</div>
            <button class="hide-timer-btn" onclick="toggleTimer()"><i class="fas fa-eye-slash"></i> <span id="timer-btn-text">Hide</span></button>
        </div>
        <div class="flex items-center gap-2" id="topic-badges">
            <span class="domain-badge">
                <span id="domain-code">{{ first_question.domain_code }}</span>
                <span id="domain-name">{{ first_question.domain_name }}</span>
            </span>
            <span class="skill-badge">
                <span id="skill-code">{{ first_question.skill_code }}</span>
                <span id="skill-name">{{ first_question.skill_name }}</span>
            </span>
        </div>
        <button class="annotate-btn" onclick="toggleAnnotate()">
            <i class="fas fa-pen"></i> Annotate
        </button>
    </div>

    {% if total_questions > 0 %}
    <!-- Practice Content -->
    <div class="practice-content">
        <!-- Stimulus/Passage Panel -->
        <div class="stimulus-panel font-lato" id="stimulus-panel">
            <div id="stimulus-content">
                {% if first_question.stimulus %}
                    {{ first_question.stimulus|safe }}
                {% else %}
                    <p class="text-sm text-gray-500">No additional context for this question.</p>
                {% endif %}
            </div>
        </div>

        <!-- Question Panel -->
        <div class="question-panel font-lato" id="question-panel">
            <div class="flex items-center justify-between">
                <span class="question-number" id="question-number">1</span>
                <div class="flex items-center gap-3">
                    <label class="mark-review">
                        <input type="checkbox" id="mark-for-review" onchange="toggleMarkForReview()">
                        <span><i class="fas fa-flag"></i> Mark for Review</span>
                    </label>
                    <button class="nav-btn" id="show-explanation-btn" onclick="toggleExplanation()" style="display: none; background: #fdcc4c; color: #262632; padding: 0.375rem 0.75rem; font-size: 0.75rem;">
                        <i class="fas fa-lightbulb"></i> Show Explanation
                    </button>
                </div>
            </div>

            <div class="question-text" id="question-stem">
                {{ first_question.stem|safe }}
            </div>

            <div class="answer-options" id="answer-options">
                {% if first_question.mcq_option_list %}
                    {% for key, value in first_question.mcq_option_list.items %}
                    <div class="answer-option" data-answer="{{ key }}" onclick="selectAnswer('{{ key }}')">
                        <span class="option-label">{{ key }}:</span>
                        <span class="option-text">{{ value|safe }}</span>
                        <button class="strikethrough-btn" onclick="toggleStrikethrough(event, this)">
                            <i class="fas fa-ban"></i>
                        </button>
                    </div>
                    {% endfor %}
                {% endif %}
            </div>

            <!-- Explanation Panel (hidden initially) -->
            <div class="explanation-panel font-lato" id="explanation-panel">
                <div class="explanation-title">Explanation</div>
                <div class="explanation-text" id="explanation-text"></div>
            </div>
        </div>
    </div>

    <!-- Footer with Navigation -->
    <div class="practice-footer">
        <button class="question-counter" id="question-counter" onclick="openQuestionMap()" style="cursor: pointer;">
            <i class="fas fa-list-ol"></i> Question <span id="current-index">1</span> of <span id="total-count">{{ total_questions }}</span>
        </button>
        <div class="navigation-buttons">
            <button class="nav-btn" onclick="endPractice()" style="background: #ef4444; color: white;">
                <i class="fas fa-stop-circle"></i> End Practice
            </button>
            <button class="nav-btn back" id="back-btn" onclick="previousQuestion()" disabled>
                <i class="fas fa-arrow-left"></i> Back
            </button>
            <button class="nav-btn" id="check-answer-btn" onclick="checkAnswer()" style="background: #10b981; color: white;" disabled>
                <i class="fas fa-check-circle"></i> <span id="check-btn-text">Check Answer</span>
            </button>
            <button class="nav-btn next" id="next-btn" onclick="nextQuestion()">
                <span id="next-btn-text">Next</span> <i class="fas fa-arrow-right"></i>
            </button>
        </div>
    </div>

    {% else %}
    <div class="empty-state">
        <h3>No Questions Available</h3>
        <p>There are no questions matching your current filters. Try adjusting your selection.</p>
    </div>
    {% endif %}

    <!-- Question Map Modal -->
    <div class="question-map-modal" id="questionMapModal">
        <div class="question-map-content">
            <div class="question-map-header">
                <h3><i class="fas fa-map"></i> Question Map</h3>
                <button class="close-modal-btn" onclick="closeQuestionMap()"><i class="fas fa-times"></i></button>
            </div>
            
            <div class="question-map-legend">
                <div class="legend-item">
                    <div class="legend-box current"></div>
                    <span>Current</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box answered"></div>
                    <span>Mastered</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box tried"></div>
                    <span>Tried</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box not-tried"></div>
                    <span>Not Tried</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box marked"></div>
                    <span>Marked</span>
                </div>
            </div>
            
            <div class="question-map-grid" id="questionMapGrid">
                <!-- Questions will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Alert Modal -->
    <div class="alert-modal" id="alertModal">
        <div class="alert-modal-content">
            <div class="alert-modal-message" id="alertMessage"></div>
            <div class="alert-modal-buttons" id="alertButtons"></div>
        </div>
    </div>

    <!-- Explanation Modal -->
    <div class="alert-modal" id="explanationModal">
        <div class="alert-modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 2px solid #e5e7eb;">
                <h3 style="font-size: 1.125rem; font-weight: 700; color: #262632;"><i class="fas fa-lightbulb"></i> Explanation</h3>
                <button class="close-modal-btn" onclick="closeExplanationModal()"><i class="fas fa-times"></i></button>
            </div>
            <div id="explanation-modal-text" style="font-size: 0.875rem; line-height: 1.6; color: #374151;"></div>
        </div>
    </div>
</div>

<script>
// Global state
const questionIds = {{ question_ids|safe }};
let currentIndex = 0;
let selectedAnswer = null;
let userAnswers = {};
let answeredCorrectly = {}; // Track which questions were answered correctly
let markedForReview = new Set();
let strikethroughOptions = {};

// Session tracking
const sessionId = '{{ session_id }}';
let questionStartTime = Date.now();

// Timer - counts up from 0 for each question
let timerSeconds = 0;
let timerInterval = null;
let timerVisible = true;

function startTimer() {
    // Clear any existing timer
    if (timerInterval) {
        clearInterval(timerInterval);
    }
    
    // Reset to 0
    timerSeconds = 0;
    updateTimerDisplay();
    
    // Start counting up
    timerInterval = setInterval(() => {
        timerSeconds++;
        updateTimerDisplay();
    }, 1000);
}

function stopTimer() {
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
}

function updateTimerDisplay() {
    const minutes = Math.floor(timerSeconds / 60);
    const seconds = timerSeconds % 60;
    const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    document.getElementById('timer').textContent = display;
}

function toggleTimer() {
    timerVisible = !timerVisible;
    const timerElement = document.getElementById('timer');
    const btn = event.target.closest('button');
    const btnText = document.getElementById('timer-btn-text');
    const btnIcon = btn ? btn.querySelector('i') : null;
    
    if (btnText && btnIcon) {
        if (timerVisible) {
            timerElement.style.display = 'block';
            btnText.textContent = 'Hide';
            btnIcon.className = 'fas fa-eye-slash';
        } else {
            timerElement.style.display = 'none';
            btnText.textContent = 'Show';
            btnIcon.className = 'fas fa-eye';
        }
    }
}

function toggleAnnotate() {
    showAlert('Annotation feature coming soon!');
}

function toggleExplanation() {
    const explanationModal = document.getElementById('explanationModal');
    explanationModal.classList.add('show');
}

function closeExplanationModal() {
    const explanationModal = document.getElementById('explanationModal');
    explanationModal.classList.remove('show');
}

// Close explanation modal when clicking outside
document.addEventListener('click', function(e) {
    const modal = document.getElementById('explanationModal');
    if (e.target === modal) {
        closeExplanationModal();
    }
});

// Alert Modal Functions
function showAlert(message, onConfirm = null) {
    const modal = document.getElementById('alertModal');
    const messageEl = document.getElementById('alertMessage');
    const buttonsEl = document.getElementById('alertButtons');
    
    messageEl.textContent = message;
    buttonsEl.innerHTML = '';
    
    if (onConfirm) {
        // Confirmation dialog with Cancel and OK buttons
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'alert-modal-btn cancel';
        cancelBtn.textContent = 'Cancel';
        cancelBtn.onclick = () => closeAlert();
        
        const confirmBtn = document.createElement('button');
        confirmBtn.className = 'alert-modal-btn confirm';
        confirmBtn.textContent = 'OK';
        confirmBtn.onclick = () => {
            closeAlert();
            onConfirm();
        };
        
        buttonsEl.appendChild(cancelBtn);
        buttonsEl.appendChild(confirmBtn);
    } else {
        // Simple alert with OK button
        const okBtn = document.createElement('button');
        okBtn.className = 'alert-modal-btn ok';
        okBtn.textContent = 'OK';
        okBtn.onclick = () => closeAlert();
        
        buttonsEl.appendChild(okBtn);
    }
    
    modal.classList.add('show');
}

function closeAlert() {
    const modal = document.getElementById('alertModal');
    modal.classList.remove('show');
}

// Question Map Modal Functions
function openQuestionMap() {
    const modal = document.getElementById('questionMapModal');
    modal.classList.add('show');
    renderQuestionMap();
}

function closeQuestionMap() {
    const modal = document.getElementById('questionMapModal');
    modal.classList.remove('show');
}

function renderQuestionMap() {
    const grid = document.getElementById('questionMapGrid');
    grid.innerHTML = '';
    
    questionIds.forEach((questionId, index) => {
        const item = document.createElement('div');
        item.className = 'question-map-item';
        item.textContent = index + 1;
        
        // Add status classes
        if (index === currentIndex) {
            item.classList.add('current');
        } else if (answeredCorrectly[questionId] === true) {
            // Question was answered correctly - show as mastered (green)
            item.classList.add('answered');
        } else if (userAnswers[questionId]) {
            // Question was attempted but not correct - show as tried (yellow)
            item.classList.add('tried');
        }
        // If no answer, it stays as not-tried (white)
        
        // Check if marked for review
        if (markedForReview.has(questionId)) {
            item.classList.add('marked');
        }
        
        // Click handler to jump to question
        item.onclick = () => {
            closeQuestionMap();
            loadQuestion(index);
        };
        
        grid.appendChild(item);
    });
}

// Close modal when clicking outside
document.addEventListener('click', function(e) {
    const modal = document.getElementById('questionMapModal');
    if (e.target === modal) {
        closeQuestionMap();
    }
});

// Question navigation
function selectAnswer(answer) {
    selectedAnswer = answer;
    
    // Update UI
    document.querySelectorAll('.answer-option').forEach(option => {
        option.classList.remove('selected');
    });
    
    event.currentTarget.classList.add('selected');
    
    // Save answer
    const currentQuestionId = questionIds[currentIndex];
    userAnswers[currentQuestionId] = answer;
    
    // Enable Check Answer button
    document.getElementById('check-answer-btn').disabled = false;
}

// Check answer with backend validation
async function checkAnswer() {
    if (!selectedAnswer) {
        showAlert('Please select an answer first!');
        return;
    }
    
    const currentQuestionId = questionIds[currentIndex];
    const checkBtn = document.getElementById('check-answer-btn');
    
    // Calculate time taken for this question
    const timeTaken = Math.floor((Date.now() - questionStartTime) / 1000);
    
    // Disable button during check
    checkBtn.disabled = true;
    const checkBtnText = document.getElementById('check-btn-text');
    const checkBtnIcon = checkBtn.querySelector('i');
    if (checkBtnText) {
        checkBtnText.textContent = 'Checking...';
    }
    if (checkBtnIcon) {
        checkBtnIcon.className = 'fas fa-spinner fa-spin';
    }
    
    try {
        const response = await fetch(`/practice/api/check-answer/${currentQuestionId}/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                answer: selectedAnswer,
                session_id: sessionId,
                time_taken: timeTaken
            })
        });
        
        const data = await response.json();
        
        // Track if answer was correct
        answeredCorrectly[currentQuestionId] = data.is_correct;
        
        // Update UI based on correctness
        document.querySelectorAll('.answer-option').forEach(option => {
            const optionAnswer = option.dataset.answer;
            
            if (data.is_correct && optionAnswer === selectedAnswer) {
                option.classList.add('correct');
            } else if (!data.is_correct && optionAnswer === selectedAnswer) {
                option.classList.add('incorrect');
            }
            
            // Show correct answer if user was wrong
            if (!data.is_correct && optionAnswer === data.correct_answer) {
                option.classList.add('correct');
            }
        });
        
        // Store explanation in modal but don't show it yet
        if (data.explanation) {
            document.getElementById('explanation-modal-text').innerHTML = data.explanation;
            
            // Render MathJax in explanation modal
            if (window.MathJax) {
                MathJax.typesetPromise([document.getElementById('explanation-modal-text')]);
            }
            
            // Show the "Show Explanation" button
            document.getElementById('show-explanation-btn').style.display = 'inline-flex';
        }
        
        // Change button text with icon
        const checkBtnText = document.getElementById('check-btn-text');
        const checkBtnIcon = checkBtn.querySelector('i');
        if (checkBtnText && checkBtnIcon) {
            if (data.is_correct) {
                checkBtnText.textContent = 'Correct!';
                checkBtnIcon.className = 'fas fa-check-circle';
                checkBtn.style.background = '#10b981';
            } else {
                checkBtnText.textContent = 'Incorrect';
                checkBtnIcon.className = 'fas fa-times-circle';
                checkBtn.style.background = '#ef4444';
            }
        }
        
    } catch (error) {
        console.error('Error checking answer:', error);
        showAlert('Failed to check answer. Please try again.');
        checkBtn.disabled = false;
        const checkBtnText = document.getElementById('check-btn-text');
        const checkBtnIcon = checkBtn.querySelector('i');
        if (checkBtnText) {
            checkBtnText.textContent = 'Check Answer';
        }
        if (checkBtnIcon) {
            checkBtnIcon.className = 'fas fa-check-circle';
        }
        checkBtn.style.background = '#10b981';
    }
}

// Helper function to get CSRF token
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

function toggleStrikethrough(e, button) {
    e.stopPropagation();
    
    const option = button.closest('.answer-option');
    const answer = option.dataset.answer;
    const currentQuestionId = questionIds[currentIndex];
    
    if (!strikethroughOptions[currentQuestionId]) {
        strikethroughOptions[currentQuestionId] = new Set();
    }
    
    if (strikethroughOptions[currentQuestionId].has(answer)) {
        strikethroughOptions[currentQuestionId].delete(answer);
        option.style.opacity = '1';
        option.style.textDecoration = 'none';
        button.classList.remove('active');
    } else {
        strikethroughOptions[currentQuestionId].add(answer);
        option.style.opacity = '0.5';
        option.style.textDecoration = 'line-through';
        button.classList.add('active');
    }
}

async function loadQuestion(index) {
    if (index < 0 || index >= questionIds.length) return;
    
    currentIndex = index;
    const questionId = questionIds[index];
    
    // Update URL with question ID
    const url = new URL(window.location);
    url.searchParams.set('question', questionId);
    window.history.pushState({}, '', url);
    
    // Show loading
    document.getElementById('stimulus-content').innerHTML = '<div class="loading">Loading...</div>';
    document.getElementById('question-stem').innerHTML = '<div class="loading">Loading...</div>';
    document.getElementById('answer-options').innerHTML = '<div class="loading">Loading...</div>';
    
    try {
        const response = await fetch(`/practice/api/question/${questionId}/`);
        const question = await response.json();
        
        // Update domain and skill badges
        document.getElementById('domain-code').textContent = question.domain_code;
        document.getElementById('domain-name').textContent = question.domain_name;
        document.getElementById('skill-code').textContent = question.skill_code;
        document.getElementById('skill-name').textContent = question.skill_name;
        
        // Update stimulus
        document.getElementById('stimulus-content').innerHTML = question.stimulus || 
            '<p class="text-sm text-gray-500">No additional context for this question.</p>';
        
        // Update question stem
        document.getElementById('question-stem').innerHTML = question.stem;
        
        // Update answer options
        const optionsHtml = Object.entries(question.mcq_options || {}).map(([key, value]) => `
            <div class="answer-option ${userAnswers[questionId] === key ? 'selected' : ''}" 
                 data-answer="${key}" 
                 onclick="selectAnswer('${key}')"
                 style="${strikethroughOptions[questionId]?.has(key) ? 'opacity: 0.5; text-decoration: line-through;' : ''}">
                <span class="option-label">${key}:</span>
                <span class="option-text">${value}</span>
                <button class="strikethrough-btn ${strikethroughOptions[questionId]?.has(key) ? 'active' : ''}" 
                        onclick="toggleStrikethrough(event, this)">
                    <i class="fas fa-ban"></i>
                </button>
            </div>
        `).join('');
        
        document.getElementById('answer-options').innerHTML = optionsHtml;
        
        // Render MathJax for mathematical expressions
        if (window.MathJax) {
            MathJax.typesetPromise([
                document.getElementById('stimulus-content'),
                document.getElementById('question-stem'),
                document.getElementById('answer-options')
            ]).catch((err) => console.log('MathJax error:', err));
        }
        
        // Update question number
        document.getElementById('question-number').textContent = index + 1;
        document.getElementById('current-index').textContent = index + 1;
        
        // Update mark for review
        document.getElementById('mark-for-review').checked = markedForReview.has(questionId);
        
        // Update navigation buttons
        document.getElementById('back-btn').disabled = index === 0;
        const nextBtn = document.getElementById('next-btn');
        const nextBtnText = document.getElementById('next-btn-text');
        const nextBtnIcon = nextBtn.querySelector('i');
        
        if (nextBtnText && nextBtnIcon) {
            if (index === questionIds.length - 1) {
                // Last question - change Next to Finish
                nextBtnText.textContent = 'Finish';
                nextBtnIcon.className = 'fas fa-flag-checkered';
                nextBtn.disabled = false;
            } else {
                nextBtnText.textContent = 'Next';
                nextBtnIcon.className = 'fas fa-arrow-right';
                nextBtn.disabled = false;
            }
        }
        
        // Reset Check Answer button
        const checkBtn = document.getElementById('check-answer-btn');
        const checkBtnText = document.getElementById('check-btn-text');
        const checkBtnIcon = checkBtn.querySelector('i');
        checkBtn.disabled = !userAnswers[questionId];
        if (checkBtnText && checkBtnIcon) {
            checkBtnText.textContent = 'Check Answer';
            checkBtnIcon.className = 'fas fa-check-circle';
            checkBtn.style.background = '#10b981';
        }
        
        // Remove correct/incorrect classes from all options
        document.querySelectorAll('.answer-option').forEach(option => {
            option.classList.remove('correct', 'incorrect');
        });
        
        // Hide explanation and reset button
        document.getElementById('explanation-panel').classList.remove('show');
        closeExplanationModal(); // Close modal if open
        const showExplanationBtn = document.getElementById('show-explanation-btn');
        showExplanationBtn.style.display = 'none';
        document.getElementById('explanation-modal-text').innerHTML = ''; // Clear modal content
        
        // Reset question start time for timing
        questionStartTime = Date.now();
        
        // Start fresh timer for this question
        startTimer();
        
        // Restore selected answer
        selectedAnswer = userAnswers[questionId] || null;
        
    } catch (error) {
        console.error('Error loading question:', error);
        showAlert('Error loading question. Please try again.');
    }
}

function previousQuestion() {
    if (currentIndex > 0) {
        loadQuestion(currentIndex - 1);
    }
}

function nextQuestion() {
    if (currentIndex < questionIds.length - 1) {
        loadQuestion(currentIndex + 1);
    } else {
        // Last question - show finish option
        showAlert(
            'You have reached the last question. Do you want to finish the practice session and view your results?',
            () => endPractice()
        );
    }
}

// End practice session
async function endPractice() {
    // Create a promise-based confirmation
    return new Promise((resolve) => {
        showAlert(
            'Are you sure you want to end this practice session? You will see a detailed report of your performance.',
            async () => {
                try {
                    await performEndPractice();
                    resolve();
                } catch (error) {
                    resolve();
                }
            }
        );
    });
}

// Actual end practice logic
async function performEndPractice() {
    try {
        const response = await fetch('/practice/api/end-practice/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                session_id: sessionId
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            window.location.href = data.redirect_url;
        } else {
            showAlert('Failed to end practice: ' + data.error);
        }
    } catch (error) {
        console.error('Error ending practice:', error);
        showAlert('Failed to end practice. Please try again.');
    }
}

async function showExplanation() {
    const questionId = questionIds[currentIndex];
    
    try {
        const response = await fetch(`/practice/api/question/${questionId}/`);
        const question = await response.json();
        
        const explanationPanel = document.getElementById('explanation-panel');
        const explanationText = document.getElementById('explanation-text');
        
        explanationText.innerHTML = question.explanation || 'No explanation available.';
        explanationPanel.classList.add('show');
        
        // Render MathJax for explanation
        if (window.MathJax) {
            MathJax.typesetPromise([explanationText]).catch((err) => console.log('MathJax error:', err));
        }
    } catch (error) {
        console.error('Error loading explanation:', error);
    }
}

// Mark for review - toggle function that saves to backend
async function toggleMarkForReview() {
    const currentQuestionId = questionIds[currentIndex];
    const markCheckbox = document.getElementById('mark-for-review');
    
    try {
        const response = await fetch('/practice/api/mark-question/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                question_id: currentQuestionId
            })
        });
        
        const data = await response.json();
        
        if (data.marked) {
            markedForReview.add(currentQuestionId);
            markCheckbox.checked = true;
        } else {
            markedForReview.delete(currentQuestionId);
            markCheckbox.checked = false;
        }
    } catch (error) {
        console.error('Error marking question:', error);
        // Revert checkbox state on error
        markCheckbox.checked = !markCheckbox.checked;
    }
}

// Load marked questions on page load
async function loadMarkedQuestions() {
    try {
        const response = await fetch('/practice/api/marked-questions/');
        const data = await response.json();
        
        if (data.marked_question_ids) {
            markedForReview = new Set(data.marked_question_ids);
        }
    } catch (error) {
        console.error('Error loading marked questions:', error);
    }
}

// Load session answers on page load
async function loadSessionAnswers() {
    try {
        const response = await fetch(`/practice/api/session-answers/${sessionId}/`);
        const data = await response.json();
        
        if (data.answers) {
            // Populate userAnswers object with previous answers
            Object.entries(data.answers).forEach(([questionId, answerData]) => {
                userAnswers[questionId] = answerData.answer;
                answeredCorrectly[questionId] = answerData.is_correct;
            });
        }
    } catch (error) {
        console.error('Error loading session answers:', error);
    }
}

// Initialize on DOM ready
document.addEventListener('DOMContentLoaded', async function() {
    // Load marked questions from backend
    await loadMarkedQuestions();
    
    // Load session answers from backend (for resumed sessions)
    await loadSessionAnswers();
    
    // Check if there's a question ID in the URL
    const urlParams = new URLSearchParams(window.location.search);
    const questionIdParam = urlParams.get('question');
    let initialIndex = 0;
    
    if (questionIdParam) {
        const foundIndex = questionIds.findIndex(id => id === questionIdParam);
        if (foundIndex !== -1) {
            initialIndex = foundIndex;
        }
    }
    
    // Load the initial question (this will start the timer)
    loadQuestion(initialIndex);
    
    // Render MathJax on initial page load
    if (window.MathJax) {
        MathJax.typesetPromise().catch((err) => console.log('MathJax initial render error:', err));
    }
});

// Keyboard navigation
document.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowLeft') {
        previousQuestion();
    } else if (e.key === 'ArrowRight') {
        nextQuestion();
    } else if (e.key >= 'A' && e.key <= 'D') {
        selectAnswer(e.key.toUpperCase());
    }
});

// Handle browser back/forward buttons
window.addEventListener('popstate', function(e) {
    const urlParams = new URLSearchParams(window.location.search);
    const questionIdParam = urlParams.get('question');
    
    if (questionIdParam) {
        const foundIndex = questionIds.findIndex(id => id === questionIdParam);
        if (foundIndex !== -1) {
            loadQuestion(foundIndex);
        }
    }
});
</script>
{% endblock %}
